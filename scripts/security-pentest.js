#!/usr/bin/env node

/**
 * ğŸ”´ PENTESTING SCRIPT - FundaciÃ³n Carmen Goudie
 * 
 * Este script simula ataques reales para encontrar vulnerabilidades
 * NO USAR EN PRODUCCIÃ“N - SOLO PARA TESTING DE SEGURIDAD
 */

const axios = require('axios');
const crypto = require('crypto');

const API_BASE = process.env.API_URL || 'http://localhost:3000/api';

// Colores para la terminal
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
};

const log = {
  attack: (msg) => console.log(`${colors.magenta}[ğŸ¯ ATTACK]${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}[âœ… EXPLOIT]${colors.reset} ${msg}`),
  fail: (msg) => console.log(`${colors.blue}[ğŸ›¡ï¸  BLOCKED]${colors.reset} ${msg}`),
  warning: (msg) => console.log(`${colors.yellow}[âš ï¸  WARNING]${colors.reset} ${msg}`),
  info: (msg) => console.log(`${colors.reset}[â„¹ï¸  INFO]${colors.reset} ${msg}`),
};

// ============================================================================
// FASE 1: RECONOCIMIENTO
// ============================================================================

async function reconnaissance() {
  log.info('=== FASE 1: RECONOCIMIENTO ===\n');

  // Test 1: Fingerprinting del servidor
  log.attack('Intentando fingerprinting del servidor...');
  try {
    const res = await axios.get(`${API_BASE}/`, { validateStatus: () => true });
    const headers = res.headers;
    
    if (headers['x-powered-by']) {
      log.warning(`X-Powered-By header expuesto: ${headers['x-powered-by']}`);
    } else {
      log.fail('X-Powered-By header oculto correctamente');
    }

    if (headers['server']) {
      log.warning(`Server header expuesto: ${headers['server']}`);
    } else {
      log.fail('Server header oculto correctamente');
    }
  } catch (err) {
    log.info(`Error en fingerprinting: ${err.message}`);
  }

  // Test 2: EnumeraciÃ³n de endpoints
  log.attack('Intentando enumerar endpoints sin autenticaciÃ³n...');
  const publicEndpoints = [
    '/auth/login',
    '/auth/refresh',
    '/onboarding/validate-invite',
    '/calls',
    '/users',
    '/applicants',
    '/admin/users',
  ];

  for (const endpoint of publicEndpoints) {
    try {
      const res = await axios.get(`${API_BASE}${endpoint}`, { 
        validateStatus: () => true 
      });
      
      if (res.status === 200) {
        log.success(`Endpoint pÃºblico encontrado: ${endpoint} (200 OK)`);
      } else if (res.status === 401) {
        log.fail(`Endpoint protegido: ${endpoint} (401 Unauthorized)`);
      } else {
        log.info(`${endpoint} â†’ ${res.status}`);
      }
    } catch (err) {
      log.info(`${endpoint} â†’ Error: ${err.message}`);
    }
  }
}

// ============================================================================
// FASE 2: ATAQUES DE AUTENTICACIÃ“N
// ============================================================================

async function authenticationAttacks() {
  log.info('\n=== FASE 2: ATAQUES DE AUTENTICACIÃ“N ===\n');

  // Test 3: SQL Injection en login
  log.attack('SQL Injection en login: admin\' OR \'1\'=\'1');
  try {
    const res = await axios.post(`${API_BASE}/auth/login`, {
      email: "admin' OR '1'='1",
      password: "password' OR '1'='1"
    }, { validateStatus: () => true });

    if (res.status === 200 && res.data.accessToken) {
      log.success('Â¡SQL INJECTION EXITOSO! Sistema comprometido');
    } else {
      log.fail(`SQL Injection bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('SQL Injection bloqueado por validaciÃ³n');
  }

  // Test 4: NoSQL Injection
  log.attack('NoSQL Injection: {$ne: null}');
  try {
    const res = await axios.post(`${API_BASE}/auth/login`, {
      email: { $ne: null },
      password: { $ne: null }
    }, { validateStatus: () => true });

    if (res.status === 200 && res.data.accessToken) {
      log.success('Â¡NoSQL INJECTION EXITOSO!');
    } else {
      log.fail(`NoSQL Injection bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('NoSQL Injection bloqueado por validaciÃ³n');
  }

  // Test 5: Brute Force con rate limiting
  log.attack('Brute Force: 15 intentos rÃ¡pidos...');
  let blockedAt = null;
  for (let i = 1; i <= 15; i++) {
    try {
      const start = Date.now();
      const res = await axios.post(`${API_BASE}/auth/login`, {
        email: 'attacker@test.com',
        password: `attempt${i}`
      }, { validateStatus: () => true });

      const elapsed = Date.now() - start;
      
      if (res.status === 429) {
        blockedAt = i;
        log.fail(`Rate limiting activado en intento ${i}`);
        break;
      }
      
      if (elapsed > 1000) {
        log.warning(`Intento ${i} tomÃ³ ${elapsed}ms (posible throttling)`);
      }
    } catch (err) {
      if (err.response?.status === 429) {
        blockedAt = i;
        log.fail(`Rate limiting activado en intento ${i}`);
        break;
      }
    }
  }

  if (!blockedAt) {
    log.warning('âš ï¸  Rate limiting NO detectado despuÃ©s de 15 intentos');
  }

  // Test 6: JWT Token tampering
  log.attack('Intentando manipular JWT token...');
  const fakeToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6IkFETUlOIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
  
  try {
    const res = await axios.get(`${API_BASE}/admin/users`, {
      headers: { Authorization: `Bearer ${fakeToken}` },
      validateStatus: () => true
    });

    if (res.status === 200) {
      log.success('Â¡JWT TAMPERING EXITOSO! Token falso aceptado');
    } else {
      log.fail(`JWT tampering bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('JWT tampering bloqueado');
  }
}

// ============================================================================
// FASE 3: ATAQUES DE INYECCIÃ“N
// ============================================================================

async function injectionAttacks() {
  log.info('\n=== FASE 3: ATAQUES DE INYECCIÃ“N ===\n');

  // Test 7: XSS en parÃ¡metros
  log.attack('XSS: <script>alert("XSS")</script>');
  try {
    const res = await axios.get(`${API_BASE}/calls`, {
      params: { q: '<script>alert("XSS")</script>' },
      validateStatus: () => true
    });

    if (res.data && typeof res.data === 'string' && res.data.includes('<script>')) {
      log.success('Â¡XSS DETECTADO! Script no sanitizado en respuesta');
    } else {
      log.fail('XSS bloqueado por sanitizaciÃ³n');
    }
  } catch (err) {
    log.fail('XSS bloqueado');
  }

  // Test 8: Command Injection
  log.attack('Command Injection: ; ls -la');
  try {
    const res = await axios.post(`${API_BASE}/applicants`, {
      email: 'test@test.com; ls -la',
      fullName: '$(whoami)'
    }, { validateStatus: () => true });

    if (res.status === 200) {
      log.warning('Comando inyectado aceptado (verificar logs del servidor)');
    } else {
      log.fail(`Command injection bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('Command injection bloqueado por validaciÃ³n');
  }

  // Test 9: Path Traversal
  log.attack('Path Traversal: ../../etc/passwd');
  try {
    const res = await axios.get(`${API_BASE}/files/../../etc/passwd`, {
      validateStatus: () => true
    });

    if (res.status === 200 && res.data.includes('root:')) {
      log.success('Â¡PATH TRAVERSAL EXITOSO! Archivo sensible accedido');
    } else {
      log.fail(`Path traversal bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('Path traversal bloqueado');
  }
}

// ============================================================================
// FASE 4: ATAQUES IDOR (Insecure Direct Object Reference)
// ============================================================================

async function idorAttacks() {
  log.info('\n=== FASE 4: ATAQUES IDOR ===\n');

  // Primero necesitamos crear dos usuarios de prueba y obtener sus IDs
  log.attack('Creando usuarios de prueba para IDOR...');
  
  const user1Email = `victim-${Date.now()}@test.com`;
  const user2Email = `attacker-${Date.now()}@test.com`;

  try {
    // Crear usuario vÃ­ctima
    const victim = await axios.post(`${API_BASE}/applicants`, {
      email: user1Email,
      fullName: 'Victim User',
      password: 'Password123!'
    }, { validateStatus: () => true });

    if (victim.status !== 200) {
      log.info('No se pudo crear usuario vÃ­ctima (endpoint puede requerir auth)');
      return;
    }

    // Login como vÃ­ctima y crear application
    const victimLogin = await axios.post(`${API_BASE}/auth/login`, {
      email: user1Email,
      password: 'Password123!'
    });

    const victimToken = victimLogin.data.accessToken;

    // Crear una application como vÃ­ctima
    const victimApp = await axios.post(`${API_BASE}/applications`, {
      callId: '00000000-0000-0000-0000-000000000001' // ID de prueba
    }, {
      headers: { Authorization: `Bearer ${victimToken}` },
      validateStatus: () => true
    });

    if (victimApp.status !== 200) {
      log.info('No se pudo crear application de vÃ­ctima');
      return;
    }

    const applicationId = victimApp.data.id;
    log.info(`Application de vÃ­ctima creada: ${applicationId}`);

    // Crear usuario atacante
    const attacker = await axios.post(`${API_BASE}/applicants`, {
      email: user2Email,
      fullName: 'Attacker User',
      password: 'Password123!'
    });

    const attackerLogin = await axios.post(`${API_BASE}/auth/login`, {
      email: user2Email,
      password: 'Password123!'
    });

    const attackerToken = attackerLogin.data.accessToken;

    // Test 10: IDOR - Intentar acceder a application de otro usuario
    log.attack(`IDOR: Atacante intenta acceder a application ${applicationId} de vÃ­ctima`);
    
    const idorAttempt = await axios.get(`${API_BASE}/applications/${applicationId}`, {
      headers: { Authorization: `Bearer ${attackerToken}` },
      validateStatus: () => true
    });

    if (idorAttempt.status === 200) {
      log.success('Â¡IDOR EXITOSO! Acceso a datos de otro usuario');
    } else if (idorAttempt.status === 403 || idorAttempt.status === 404) {
      log.fail(`IDOR bloqueado (${idorAttempt.status})`);
    }

    // Test 11: IDOR - Intentar modificar application de otro usuario
    log.attack('IDOR: Intentar modificar application de vÃ­ctima');
    
    const idorModify = await axios.patch(`${API_BASE}/applications/${applicationId}`, {
      academic: { grade: 100 }
    }, {
      headers: { Authorization: `Bearer ${attackerToken}` },
      validateStatus: () => true
    });

    if (idorModify.status === 200) {
      log.success('Â¡IDOR CRÃTICO! ModificaciÃ³n de datos de otro usuario exitosa');
    } else {
      log.fail(`IDOR de modificaciÃ³n bloqueado (${idorModify.status})`);
    }

  } catch (err) {
    log.info(`IDOR tests omitidos: ${err.message}`);
  }
}

// ============================================================================
// FASE 5: ESCALACIÃ“N DE PRIVILEGIOS
// ============================================================================

async function privilegeEscalation() {
  log.info('\n=== FASE 5: ESCALACIÃ“N DE PRIVILEGIOS ===\n');

  // Test 12: Mass Assignment - Intentar cambiar rol a ADMIN
  log.attack('Mass Assignment: Intentar crear usuario APPLICANT con role=ADMIN');
  
  try {
    const res = await axios.post(`${API_BASE}/applicants`, {
      email: `hacker-${Date.now()}@test.com`,
      fullName: 'Hacker User',
      password: 'Password123!',
      role: 'ADMIN', // Intentar inyectar rol de admin
      isActive: true
    }, { validateStatus: () => true });

    if (res.status === 200) {
      // Verificar si el usuario creado tiene rol ADMIN
      const login = await axios.post(`${API_BASE}/auth/login`, {
        email: res.data.email,
        password: 'Password123!'
      }, { validateStatus: () => true });

      if (login.data.accessToken) {
        // Decodificar JWT para ver el rol
        const payload = JSON.parse(
          Buffer.from(login.data.accessToken.split('.')[1], 'base64').toString()
        );

        if (payload.role === 'ADMIN') {
          log.success('Â¡ESCALACIÃ“N EXITOSA! Usuario creado con rol ADMIN');
        } else {
          log.fail(`Mass assignment bloqueado - Rol: ${payload.role}`);
        }
      }
    } else {
      log.fail(`Mass assignment bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('Mass assignment bloqueado por validaciÃ³n');
  }

  // Test 13: JWT Role tampering
  log.attack('Intentar manipular rol en JWT token...');
  
  try {
    // Crear usuario legÃ­timo
    const email = `user-${Date.now()}@test.com`;
    await axios.post(`${API_BASE}/applicants`, {
      email,
      fullName: 'Test User',
      password: 'Password123!'
    }, { validateStatus: () => true });

    const login = await axios.post(`${API_BASE}/auth/login`, {
      email,
      password: 'Password123!'
    });

    const originalToken = login.data.accessToken;
    const [header, payload, signature] = originalToken.split('.');
    
    // Decodificar payload
    const decodedPayload = JSON.parse(Buffer.from(payload, 'base64').toString());
    
    // Cambiar rol a ADMIN
    decodedPayload.role = 'ADMIN';
    
    // Crear nuevo token con rol modificado (sin firma correcta)
    const tamperedPayload = Buffer.from(JSON.stringify(decodedPayload)).toString('base64');
    const tamperedToken = `${header}.${tamperedPayload}.${signature}`;

    // Intentar acceder a endpoint de admin
    const adminAccess = await axios.get(`${API_BASE}/admin/users`, {
      headers: { Authorization: `Bearer ${tamperedToken}` },
      validateStatus: () => true
    });

    if (adminAccess.status === 200) {
      log.success('Â¡JWT ROLE TAMPERING EXITOSO! Acceso admin obtenido');
    } else {
      log.fail(`JWT role tampering bloqueado (${adminAccess.status})`);
    }

  } catch (err) {
    log.fail('JWT role tampering bloqueado');
  }
}

// ============================================================================
// FASE 6: ATAQUES DE DENEGACIÃ“N DE SERVICIO (DoS)
// ============================================================================

async function dosAttacks() {
  log.info('\n=== FASE 6: ATAQUES DOS ===\n');

  // Test 14: Payload Bomb (JSON muy grande)
  log.attack('Payload Bomb: Enviando JSON de 10MB...');
  
  const hugePayload = {
    email: 'test@test.com',
    data: 'A'.repeat(10 * 1024 * 1024) // 10MB de datos
  };

  try {
    const start = Date.now();
    const res = await axios.post(`${API_BASE}/applicants`, hugePayload, {
      validateStatus: () => true,
      timeout: 5000
    });

    const elapsed = Date.now() - start;

    if (res.status === 413) {
      log.fail('Payload bomb bloqueado (413 Payload Too Large)');
    } else if (res.status === 400) {
      log.fail('Payload bomb bloqueado por validaciÃ³n');
    } else {
      log.warning(`Payload aceptado en ${elapsed}ms (revisar lÃ­mites)`);
    }
  } catch (err) {
    if (err.code === 'ECONNRESET' || err.message.includes('timeout')) {
      log.warning('Servidor desconectado/timeout (posible DoS)');
    } else {
      log.fail('Payload bomb bloqueado');
    }
  }

  // Test 15: ReDoS (Regular Expression Denial of Service)
  log.attack('ReDoS: Regex evil pattern...');
  
  const evilPattern = 'a'.repeat(50) + 'X'; // Pattern que causa catastrophic backtracking
  
  try {
    const start = Date.now();
    const res = await axios.get(`${API_BASE}/calls`, {
      params: { q: evilPattern },
      validateStatus: () => true,
      timeout: 3000
    });

    const elapsed = Date.now() - start;

    if (elapsed > 2000) {
      log.warning(`Query tomÃ³ ${elapsed}ms (posible ReDoS vulnerability)`);
    } else {
      log.fail(`ReDoS bloqueado/no vulnerable (${elapsed}ms)`);
    }
  } catch (err) {
    if (err.message.includes('timeout')) {
      log.success('Â¡ReDoS EXITOSO! Servidor en timeout');
    } else {
      log.fail('ReDoS bloqueado');
    }
  }
}

// ============================================================================
// FASE 7: EXFILTRACIÃ“N DE DATOS
// ============================================================================

async function dataExfiltration() {
  log.info('\n=== FASE 7: EXFILTRACIÃ“N DE DATOS ===\n');

  // Test 16: EnumeraciÃ³n de usuarios
  log.attack('EnumeraciÃ³n: Intentar listar todos los usuarios...');
  
  try {
    const res = await axios.get(`${API_BASE}/applicants`, {
      params: { limit: 10000, offset: 0 },
      validateStatus: () => true
    });

    if (res.status === 200 && res.data.data) {
      if (res.data.data.length > 0) {
        log.warning(`EnumeraciÃ³n exitosa: ${res.data.data.length} usuarios listados sin auth`);
        
        // Verificar si incluye informaciÃ³n sensible
        const firstUser = res.data.data[0];
        if (firstUser.email) {
          log.warning('Emails expuestos en listado');
        }
        if (firstUser.passwordHash || firstUser.password_hash) {
          log.success('Â¡CRÃTICO! Password hashes expuestos');
        }
      }
    } else if (res.status === 401) {
      log.fail('EnumeraciÃ³n bloqueada (requiere autenticaciÃ³n)');
    }
  } catch (err) {
    log.fail('EnumeraciÃ³n bloqueada');
  }

  // Test 17: SQL Injection para dump de base de datos
  log.attack('SQL Injection avanzado: UNION SELECT...');
  
  try {
    const res = await axios.get(`${API_BASE}/applicants/1' UNION SELECT NULL,email,password_hash,NULL,NULL FROM users--`, {
      validateStatus: () => true
    });

    if (res.status === 200 && res.data) {
      log.success('Â¡SQL INJECTION UNION EXITOSO! Posible data dump');
    } else {
      log.fail(`SQL Injection UNION bloqueado (${res.status})`);
    }
  } catch (err) {
    log.fail('SQL Injection UNION bloqueado');
  }
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                â•‘
â•‘   ğŸ”´ PENTESTING - FUNDACIÃ“N CARMEN GOUDIE                     â•‘
â•‘                                                                â•‘
â•‘   âš ï¸  DISCLAIMER: Solo para testing de seguridad              â•‘
â•‘   âš ï¸  No usar contra sistemas sin autorizaciÃ³n                â•‘
â•‘                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);

  log.info(`Target: ${API_BASE}\n`);

  try {
    await reconnaissance();
    await authenticationAttacks();
    await injectionAttacks();
    await idorAttacks();
    await privilegeEscalation();
    await dosAttacks();
    await dataExfiltration();

    console.log(`\n
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    PENTESTING COMPLETADO                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `);

    log.info('Revisa los resultados arriba para identificar vulnerabilidades.');
    log.info('Los items marcados con âœ… EXPLOIT son vulnerabilidades REALES.');
    log.info('Los items marcados con ğŸ›¡ï¸  BLOCKED estÃ¡n protegidos correctamente.');

  } catch (err) {
    console.error('Error en pentesting:', err.message);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main };
